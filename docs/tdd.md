## テスト駆動開発（TDD: Test Driven Development）

### 目次
1. テストを先に書いて、コードは後で書く: なんで？
1. pytestの使い方： テストコードを使いまわそう
1. テストケースの作り方: 境界値や大きすぎるデータへの対応

---
#### 1. テストを先に書いて、コードは後で書く: なんで？
競技プログラミングなどのコーディングテストは、ある入力に対してある出力を解答して答え合わせをします  
サンプルとしていくつかの入力例と出力例のセットが渡されるため、解答コードは最低限この入出力セットが一致するように作らねばいけません  
提出後の答え合わせではサンプル以外にも多くの入出力のセットがあり、それぞれが一致して初めて満点となる仕組みです

プログラミングテストということで、コードを書かなければ採点プログラムも動かせません  
それでもなぜテストを先に書くかというと、入出力のセットという補助輪を使って徐々にコードを正解の形へ近づけることができるからです  
関数を組み合わせて入力を正解へと近づけていきましょう


#### 2. pytestの使い方： テストコードを使いまわそう
`src/solution.py`というコードに対するテストは`tests/test_solution.py`に書きます  
ソースコードは`src/*.py`、テストコードは`tests/test_*.py`という形で作成します  
また、テストコードの中で実行するテストケースは`def test_*():`という形で定義します

pytestでは同じ関数に対して様々な値を入力してテストが通るか試すparametrizeという機能があります  
実例を見せましょう

テストケースは`test_solution.py`で記述します
```python
import pytest
from src.solution import *


@pytest.mark.parametrize("a, b, expected", [
        (1, 2, 3),
])
def test_add(a, b, expected):
    actual = add(a, b)
    assert actual == expected
```

このテストケースを通過する最短の関数`add(a, b)`は次の形です
```python
def add(a, b):
    return 3
```
どんな入力だろうが`3`を返す関数です  
当然、引数に`a=1, b=2`が入力されようがされまいが`add(a, b)`は`3`を返します  
`Teaching-Assistant-Python`ディレクトリ上に移動し、ターミナルで`pytest`を実行してください
テストケースの期待値`expected`は`3`なので、このテストケースは通過します　　

もちろん、他のテストケースでは通用しませんよね  
テストコードにテストケースを追加します
```python
import pytest
from src.solution import *


@pytest.mark.parametrize("a, b, expected", [
        (1, 2, 3),
        (2, 3, 5)
])
def test_add(a, b, expected):
    actual = add(a, b)
    assert actual == expected
```

新たに追加されたテストケースは2+3=5ですが、`add(a, b)`は3しか返しません  
コードの修正が必要です！！！

```python
def add(a, b):
    return a + b
```
単純ですが、これで必ず`add(a, b)`はaとbの和を返すようになりました


テスト駆動開発は
1. テストを失敗させる
1. 絶対に成功しかない単一パターンを返す関数を作る
1. 単一パターンしか返せないのでテストケースを増やすと失敗する
1. テストケースを通過するコードを書く

この繰り返しでどんなテストケースでも期待通りの値を返すように直していきます  
込み入った処理がある場合は関数を分割しても構いません  


#### 3. テストケースの作り方: 大きすぎるデータや境界値への対応
- 巨大なデータ: メモリ制限が厳しくてまともに展開できないいやらしいやつ
- 境界値: テストケースの条件ギリギリを攻めてくるいやらしいやつ

巨大なデータに関してはアルゴリズムという、データ処理の仕方で工夫してどうにかする手法を取らざるを得ないと思います  
int型やstr型のデータを他のデータと合わせてプログラミングコンテストのメモリ上限512MB程度まで使い切るようなコーディングは避けなければいけません  
ただ、未経験歓迎や第二新卒歓迎を謳う企業であれば、むしろメモリ限界まで使い切るようなコーディングをすることはほぼ無いと言ってもいいでしょう  
データ処理の方法を工夫できるのではないか、など色々考えてみてください  
上級者向けの問題はむしろこのようなデータを上手く捌けという問題が目白押しです  

さて、もう一個の境界値とはなんでしょうか  
たとえば、ある24時間営業の飲食店は11:00~15:00の間、ランチタイム営業を行っているとします  
ランチタイムであれば500円引き、通常営業時は割引なしの値段で営業しています  
ここで、ランチタイム営業時間であるかどうかをbool値で返す関数`is_lunch_time(now_time)`を考えます

`now_time`以外の時間、たとえば18:00は`False`が必ず返ってくるでしょう  
`now_time`中の時間、たとえば12:00は`True`が必ず返ってくるでしょう
このような値を返すソースコードを準備します

```python
# now_timeは不等号で比較できる型とする
def is_lunch_time(now_time, expected):
    if now_time == "18:00":
        return False
    elif now_time == "12:00":
        return True        
```

この二つの値はそれぞれ無効同値・有効同値といい、値が有効/無効となる範囲の代表値として範囲内の中から選んだものです  
このような値をすべて羅列したら完璧なテストコードが完成するでしょう  
しかし、とてつもなく面倒で非効率だと言えます  
代表値の他に、`True`と`False`が切り替わる境界となる値にバグは潜みます  
今回であれば10:59までは通常営業で、11:00から15:00まではランチタイム営業、そして15:01から通常営業に切り替わります

```python
import pytest
from src.restaurant import *


# now_timeは不等号で比較できる型とする
@pytest.mark.parametrize("now_time, expected", [
                            ("18:00", False),  #　通常営業の代表時間
                            ("12:00", True),   # ランチ営業の代表時間
                            ("10:59", False),  # 通常営業の終了時間
                            ("11:00", True),   # ランチ営業の開始時間
                            ("15:00", True),   # ランチ営業の終了時間
                            ("15:01", False),  # 通常営業の開始時間
])
def test_is_lunch_time(now_time, expected):
    actual = is_lunch_time(now_time)
    assert actual == expected    
```

上記のように、サンプル入出力以外にも条件から境界値を考えてテストしておくと点の取りこぼしは少なくなります